#!/bin/bash

# Check if this script is run using sudo privileges
# Source: https://askubuntu.com/questions/15853/how-can-a-script-check-if-its-being-run-as-root
if [[ $EUID -ne 0 ]]; then # check effective user id, and if it not root (!id=0) then ask for permission.
    echo "Please run this script using the sudo command!"
    exit 1
fi





check_username_valid_chars(){
    #   task: check if the username that user provide is usable (no special charecter)
    #   parameter: username($1)
    #   return: 0,1
    
    
    #   explanation
    #   the function loop through the list of special charecter and check if the username contain any of them
    #
    local username=$1 # get the user name from positional argument 1 and make it local, since we dont want other function to be able to use the username
    
    #defind list of special charecter
    special_char=("!" "@" "#" "$" "%" "^" "&" "*" "(" ")" "-" "_" "=" "+" "{" "}" ";" ":" "/" "?" "." ">") 

    for char in ${special_char[@]}; do # loop each special charecter name it char
        if [[ $username == *"$char"* ]]; then # check if username contain any special charecter
            echo "Username can't contain special characters."
            return 1 # return true once it found any spcial chareter in username
        fi
    done
    
    return 0 # if it finish the loop without find any special charecter then return 0
}


check_username_exists(){
    #   task: checks if the username entered by the user already exists in the passwd file or not.
    #   parameter: username($1)
    #   return: 0,1
    
    #   explanation
    # If the username already exists, return 1 and echo "This username has already been used."
    local username=$1 # get the user name from positional argument 1 and make it local, since we dont want other function to be able to use the username

    usedUserName=$(cut -d: -f1 /etc/passwd ) # Get the list of all usernames in the passwd file by cutting from :, and get the first field (index 0) which equal to user name
    usedUserName=(${usedUserName[0]}) # make string to array
    
    # Loop over existing usernames(usedUserName) in the passwd file. If the name provided by the user matches one of them, return 1 and echo "This username has already been used.", this will check if username that user enter match any existign username 
    for name in ${usedUserName[@]}; do # starting loop by loop over usedUserName
        if [[ $name == $username ]]; then # check if enter name is equal to the name in used name 
            echo "This username has already been used."
            return 1 # if it found any match then return 1
        fi
    done
    
    return 0 # if it finish loop without find any match then return 0
    
}
check_shellpath(){
    #   task: checks if the shell path entered by the user exists (is a real shell available for use).
    #   parameter: shellpath($1)
    #   return: 0,1
    
    #   explanation
    # If the shell path is not available, return 1 and echo "Invalid shell path."
    # the function will check if the shell path is in the /etc/shells file
    # if enterpath is null, return 0 because it will get the default shell (in create_user function)
    
    local userShell=$1 #get the positonal argument 1 and assign it to usershell
    if [[ ! -z $userShell ]]; then # check if the username is not empty (null)
        shellList=$(tail -n +4 /etc/shells | cat ) # Get the available shells (ignore the first 3 lines, thus using tail -n+4) and save them in the variable shellList
        shellList=(${shellList[0]}) # make string to araay
        
        # Check if the user shell path is available by comparing it to the variable shellList
        for shell in ${shellList[@]}; do # looping over the available shell list
            if [[ $shell == $userShell ]]; then # if one of the shell is match with shell path that user enter then return 0
                return 0
            fi
        done
        echo "Invalid shell path." # if loop is done meaning no shell path match, then echo and return 1
        return 1 
    fi
    return 0 # return 0 if shell path null since the other function will assign the default shell path, if no shell path given
    
    
    
}
assign_user_id(){
    #  Task: determines a new user ID from the existing users in the passwd file.
    #  Parameter:
    #  Return: userID
    
    
    # It checks if the ID is taken or not. If not, it assigns it to the new user.
    
    # usedUserID stores the values of user IDs already created, by using cut from : and selecting the third position to get the ID number in the passwd file.
    usedUserID=$(cut -d ":" -f3 /etc/passwd )    # usedUserID stores a list of existing user IDs
    
    #make string to array
    usedUserID=(${usedUserID[0]})
    local userID

    # the following code will try to assign the user id by finding the available id (id is not in used)

    local i=1000 # defind variable i, i will be use as user id when the condition met (start from 1000 because userID)
    while [[ -z $userID ]];do # start the loop by check if the userID is still empty (not assign yet)
        if [[ $i -eq 65534 ]];then # first check i is not 65534 since it need to preserve as nobody user
            continue # if the condition met then skip the rest of the loop and start the new loop
        fi

        if [[ ! ${usedUserID[@]} =~ $i ]];then # check if i is not in usedID (availble to use for the new user)
            userID=$i # if the i is not in used id then assign to ther UserID
            break # stop the loop
        fi
        
        ((i++)) # at the end of each loop, increase the value of i by 1

    done



    
    
    echo $userID # return userID
}
assign_group_id(){
    #   task: Check if userID can be used as group ID (usually group ID matches userID)
    #   parameter: userID($1) 
    #   return: groupID
    
    
    local userID=$1 #get the positional argument 1 and assign to local variable userID
    
    ## the following code Check if userID can be used as group ID (usually group ID matches userID)

    usedGroupID=$(cut -d ":" -f3 /etc/group) # get all of the group id by using cut from : and get the third field in /etc/group file
    if [[ ${usedGroupID[@]} =~  $userID ]]; then # If userID is already in group ID (meaning group ID is already taken)
        echo "User ID is not available to use as group ID." >&2 
        echo "Assigning new group ID.......">&2
        declare groupid # delclear an empty variable name group id
        
        # Find an available group ID. Now, user ID and group ID will not match, but it will try to create a group ID for the user.
        
        # Find an available group ID. If the ID is available (not in used IDs), it assigns it to the variable groupid. (this step is similar to find user id but now we find id in /etc/group)
        # the following code will try to assign the group id by finding the available id (id is not in used)

        local i=1000 # defind variable i, i will be use as group id when the condition met (start from 1000 because userID)
        while [[ -z $groupid ]];do # start the loop by check if the groupid is still empty (not assign yet)
            if [[ $i -eq 65534 ]];then # first check i is not 65534 since it need to preserve as nobody group
                continue # if the condition met then skip the rest of the loop and start the new loop
            fi

            if [[ ! ${usedGroupID[@]} =~ $i ]];then # check if i is not in usedID (availble to use for the new user)
                groupid=$i # if the i is not in used id then assign to ther UserID
                break # stop the loop
            fi
            
            ((i++)) # at the end of each loop, increase the value of i by 1

        done
        echo $groupid

    else # this mean user id is not in group id which mean it available to be use as group id
        echo $userID #return userID, which will use as group id
        
    fi
    
    
}
mkhomeDir(){
    #   Task:  Create a home directory for user
    #   Parameter: userHome($1)
    #   Return: 0,1
    
    local userHome=$1
    
    ### Create a home directory using mkdir
    if mkdir $userHome; then 
        echo "Home directory created successfully."
        
    else
        echo "An error occurred."
        return 1
    fi
    
    ## Copy the contents from /etc/skel to the home directory that create recently 
    if cp -r /etc/skel/. $userHome; then
        echo "Settings copied from /etc/skel successfully."
        return 0
    else
        echo "An error occurred."
        return 1
    fi
    
    
}


create_user(){
    #   Task: create user data that can be appended to the passwd and group files
        # - using the other function to check the argument 
    #   Parameter: username($1), userInfo($2), userShell($3)
    #   Return: 0,1
    
    #   explanation
    # 0. check the argument that given to this function by using function 
    # 1. assign variables (username, userShell, userHome, userID, groupid) and make it global variable
    # 2. make home directory for user (from the function mkhomeDir)
    # 3. append user data to passwd file 
    # 4. append user data to group file
    # 5. change ownership of home directory
    
    
    # 0. checking argument
    # before assigning variables, check if the arguments are valid from function (check_username_valid_chars check_username_exists check_shellpath)
    # this will run every checking function and pass down the argument, if any one of the checking function return 1 then stop the script
    # if all of the checking function run successfully, it will assign the arguments to the variables (global)


    checking_func=(check_username_valid_chars check_username_exists check_shellpath) #defind checking function 
    checking_arguments=($1 $1 $3) # defind the argument that will be pass down to the function
    for i in {0..2}; do #start loop 3 time (checking_func size)
        ${checking_func[$i]} ${checking_arguments[$i]} #run the checking function with argument 
        if [[ $? -eq 1 ]]; then # check if any exit code (also return ) is equal to one
            return 1 # if any function return one then stop script and return 1 (fail)
        fi
    done
    
    
    
   
    # 1 assign positional argument to user name, usershell, userInfo, userID, groupid (all of them are global variable)
    username=$1
    userShell=$3
    userHome="/home/$username"
    userInfo=$2
    userID=$(assign_user_id) # run the function assign_user_id and assign it to variable name userID
    groupid=$(assign_group_id $userID) # run the assign_group_id and assign it to groupid
    
    # 1.1 assign shell path if not provided
    # Check if the user provided a shell path. If not, set the shell to the default: /bin/bash
    if [[ -z $3 ]]; then # check if positionl argument is empty 
        echo "No shell path provided, setting shell to default: /bin/bash" 
        userShell="/bin/bash" # assign the default value (/bin/bash) to the usershell variable
    fi
    
    
    # 2. make home directory
    if ! mkhomeDir $userHome ; then
        echo "failed to create home directory"
        return 1
    fi
    
    
    # 3. append user data to passwd file
    
    # Declare userdetail containing user data in the form that can be appended to passwd
    userdetail="$username:x:$userID:$groupid:$userInfo:$userHome:$userShell"
    
    # Add user detail to passwd file using shell redirection (>> becauase we trying to add not overwrite)
    echo $userdetail >> /etc/passwd || { echo "failed to add user to passwd file" >&2; return 1; }
    echo "User details added to passwd file" >&2 
    
    
    # 4. append user data to group file
    
    # Make a group detail from user that just created in the form that can be added to /etc/group file
    groupDetail=$username:x:$groupid:
    # Append the group detail to the group file in the /etc folder using shell redirection
    echo $groupDetail >> /etc/group || { echo "failed to add user to group file" >&2; return 1; }
    
    
    # 5. change ownership of home directory
    # Assign permissions to the user to own all the files inside their home directory
    chown -R $username:$username $userHome || { echo "failed to change ownership of home directory" >&2; return 1; }
    
    # 6. assign password to the user
    passwd $username || { echo "failed to assign password" >&2; return 1; }
    

    #done, now printing out all of the user information
    echo "------- user details -------"
    echo username: $username
    echo comment : $userInfo
    echo shell: $userShell
    echo home: $userHome
    echo userid: $userID
    echo groupid: $groupid
    echo "------- user details -------"
    
    
    
}



adduserGroup(){
    #   Task: add user to existing group (in /etc/group)
    #   Parameter: groupname
    #   Return: 0,1
    
    # This function is used with the -g flag to add a user to a specific group
    
    
    # Get the arguments and put them in variables entergroup (the group the user entered) and username (the user to be added to the group)

    local entergroup=($@)

    
    # If the argument is null, then return 0; it won’t add any user to the group or run the code below
   
    if [[ -z $entergroup ]]; then
        return 0
    fi
    groupNames=$(cut -d: -f1 /etc/group ) # Get the list of group names in /etc/group
    groupNames=(${groupNames[0]}) # Adjust index in the list
    
    for group in ${entergroup[@]};do

        if [[ ! ${groupNames[@]} =~ $group ]]; then # Check if the group entered exists in the file
            echo "The $group group you’re trying to add the user to does not exist!" # If it doesn’t exist, echo to inform the user
            continue

            
        else # If the group exists, it will try to add the user to the /etc/group file (code below)
            
            # Get the list of group names by using awk
            # Separate each position by -F:, -v to pass the value to awk
            # Check if the first field on any line matches the entergroup
            groupmatch=$(awk -F: -v group="$group" '$1 == group {print}' /etc/group)
            
            # Get the line number of the group by using grep -n to get the line number, then cut to get the line number only
            numberline=$(grep -n $groupmatch /etc/group | cut -d: -f1 )
    
            
            # Check if the group the user is trying to add has group members or not. If there are members, add a comma before the username.
            groupmember=$(grep -n $groupmatch /etc/group | cut -d: -f5 )
            
            if [[ -z $groupmember ]]; then # If the group has no members
                
                sed -i "${numberline}s/$/$username/" /etc/group # Insert the username at the end of the line (line $number line)
            else
                sed -i "${numberline}s/$/,$username/" /etc/group # Insert the username with a comma before the name at the end of the line
            fi
            
            echo "User added to group ${group} successfully!" # Add a check to verify that it worked, if necessary
        fi
    done
    return 0
}

while getopts "s:m:g:hpc:" opt; do
    case $opt in
        m)
            m_flag=true
            enterName=${OPTARG}
        ;;
        s)
            s_flag=true
            enterShell=${OPTARG}
        ;;
        g)
            g_flag=true
            enterGroup=${OPTARG}
        ;;
        c)
            c_flag=true
            
            enterComment=${OPTARG}
            ;;
        ?)
        ;;
    esac
done


if [[ -z $@ ]]; then
    echo "Usage: sudo userSet [OPTION].....
    -m <username> create user
    -s <shellPath> assign shell path
    -g <groupname> add user to the existing group
    -c <comment> to add comment
    For more information: -h"
elif [[ ! $m_flag ]]; then
    echo "This script requires -m <user name>"
elif [[ $m_flag && $g_flag ]]; then
    # give the default the comment and shell, since this two argument are not require
    
    create_user "$enterName" "$enterComment" "$enterShell"
    if [[ $? -eq 0 ]]; then
      
        echo adding group...
        adduserGroup "$enterGroup"
    fi
else
    create_user "$enterName" "$enterComment" "$enterShell"
fi

# Links
# https://www.baeldung.com/linux/find-available-shells#:~:text=To%20find%20available%20shells%20on,shells%20installed%20on%20the%20system.
# https://stackoverflow.com/questions/62887981/modifying-a-particular-line-in-a-text-file-from-the-command-line
