#!/bin/bash


# if no argument/flag provide then explain what the script can do
if [[ -z $1 ]];then
    echo "Usage: sudo userSet [OPTION].....
    -m <username> create user
    -s <shellPath> assign shell path
    -g <groupname> add user to the existing group
    for more information -h"
    
fi

# check if this script is run by using sudo privillage 
# source: https://askubuntu.com/questions/15853/how-can-a-script-check-if-its-being-run-as-root
if [[ $EUID -ne 0 ]];then
    echo please run this script using sudo command!
    exit 1
fi








create_user(){

   # declear the values that need to be use in this function
   username=$1
   userShell=$2
   userHome="/home/$username"
   userInfo=$3


    ############# username checking #######################
    #
    # this error handling check if the username that user enter is already exist in passwd file or not
    # if the username is already exist then it will print out error


    usedUserName=$(cut -d ":" -f1 /etc/passwd ) # get the list of the user name in passwd file, by cutting from :, and get the first field (index 0)
    usedUserName=(${usedUserName[0]}) # adjust the array to make the position match index

    
    # loop over the exist username in passwd file, if the name that user provide is match one of them, then return 1 and echo "this user name has already been used"
    for name in ${usedUserName[@]};do 
        if [[ $name == $username ]];then
            echo "this user name has already been used"
            return 1
        fi
    done

    ####################### Check User name charecter ################
    # this code section check if the user name that user provide is valid (no special charecter)
    special_char=("!" "@" "#" "$" "%" "^" "&" "*" "(" ")" "-" "_" "=" "+" "{" "}" ";" ":" "/" "?" "." ">")
    for char in ${special_char[@]};do
        if [[ $username == *"$char"* ]];then
            echo "username can't contain special charecter"
            exit 1
        fi
    done

    
    #check if user provide shell path, if not that give them a default shell path (/bin/bash)
    if [[ -z $2 ]];then
        echo "no shell path provide, the shell set to default : /bin/bash"
        userShell="/bin/bash"

    fi

   
    ############# error handling for shell path ######################
    #this will check if the shell path that user enter is exist ( real shell available to use)

    shellList=$(tail -n +4 /etc/shells | cat ) # get the available shell (dont want the first 3 line, thus use the tail -n+4) and save it in variable shellList
    shellList=(${shellList[0]}) #adjust index array 
    
    # check if one of the user shell path is available, by comparing it to the variable shellList
    if [[ ! ${shellList[@]} =~ $userShell ]];then
        echo "invalid shell path" #if not match one of them then return 1
        return 1
    fi

    


    ######################## ASSIGN new user ID #######################
    # this section of the code determine what new user id from the existing user in passwd
    # it check in the passwd file if the id is taken or not, if not then assign it to the new user

    # useduserID store the value of the userID that has been created, by using cut from : and select third position, to get the ID number in the passwd file
    usedUserID=$(cut -d ":" -f3 /etc/passwd )    # usedUserID store list of exist userID

    

    #adjust userID index
    usedUserID=(${usedUserID[0]})



    #find the available id from the range of 1000-65533, if the id is available(not in used id) then it assign to variable call userID. 
    for i in {1000..65533};do
        if [[ ! ${usedUserID[@]} =~ $i ]];then
            userID=$i # if the index (i) is not in usedid, then assign the index to UserID and stop the loop
            break
        fi


    done 
    # if the userID variable still empty then it will start another loop starting from id 65535 to 4294967295
    if [[ -z $userID ]];then

        for i in {65535..4294967295};do
        if [[ ! ${usedUserID[@]} =~ $i ]];then
            userID=$i
            break
        fi


        done 
    fi
    
   
    ############## APPEND user data to passwd file ###############

   #delcare userdetail containing a user data in the form that can be append in passwd
    userdetail="$username:x:$userID:$userID:$userInfo:$userHome:$userShell"


    
    #add user detail to passwd file by using shell redirection
    echo $userdetail >> /etc/passwd
    echo "added user detail to passwd file" >&2

    ############### Make Home Dir for User ####################
    ### make home dir, by using make dir
    if mkdir $userHome;then
        echo "create home directory successfully"
    else
        echo "An error occured"
    fi
    ##copy the content /etc/skel
    if cp -r /etc/skel/. $userHome;then
        echo "copy setting from /etc/skel successfully"
    else
        echo "An error occured"
        return 1
    fi

    ################### ADD user pasword ####################
    ##add user password by using passwd to setup password with the new user
    passwd $username


    ################## Make Group for User ##################

    ## check if user id can be use as group id ( usually group id will equal to user id)
    usedGroupID=$(cut -d ":" -f3 /etc/group)  
    if [[ ${usedGroupID[@]} =~  $userID ]];then # if userid is already in group id ( mean group id is already taken)
        echo "user id is not available to use as group id"
        echo "assigning new group id......."
        declare groupid

        #find a available group id (now user id and group id will not match but it will try to create a group id for user)

        #find the available id from the range of 1000-65533, if the id is available(not in used id) then it assign to variable call groupid. 
        for i in {1000..65533};do
            if [[ ! ${usedGroupID[@]} =~ $i ]];then
                groupid=$i # if the index (i) is not in usedid, then assign the index to UserID and stop the loop
                break
            fi


        done 
        # if the userID variable still empty then it will start another loop starting from id 65535 to 4294967295
        if [[ -z $groupid ]];then

            for i in {65535..4294967295};do
            if [[ ! ${usedGroupID[@]} =~ $i ]];then
                groupid=$i
                break
            fi


            done 
        fi
    else
    echo group id : $userID
    groupid=$userID
    fi






    #make a group detail, in form that can be add in /etc/group file
    groupDetail=$username:x:$groupid:
    # append the group detail to the file group in etc folder by using shell redirection
    echo $groupDetail >> /etc/group

    ################## CHANGE the permission #################
    # make the permission of the user to own all of the file inside their home directory :)
    chown -R $username:$username $userHome
}

    




adduserGroup(){
    ############# ADD USER TO OTHER GROUP ######################
    # this function is use with flag -g to add user to specific group 
    # take 2 argument which are group name and username

    #get the argunent and put in the var entergroup(the group user has enter), and username of the user that trying to add to the group
    local entergroup=$1
    local username=$2
    # if the argument is null then return 0, thus it not going to add anyuser to the group or run the below code
    if [[ -z $1 ]];then
        return 0
    fi
   
    groupNames=$(cut -d ":" -f1 /etc/group ) # get the list of the group name in /etc/group
    groupNames=(${groupNames[0]}) # adjust index in the list
   
    if [[ ! ${groupNames[@]} =~ $entergroup ]];then #check if the group that user enter is exist in the file
        echo "the group you trying to add user too does not exist!" # if it not exist then echo to tell user that the group that he/she trying to add is not exist  

    else # if the group exist then it will trying to add user to the file /etc/group ( code below)

        
        # get the list of group name by using awk
        # seperte each position by -F:, -v to pass the value to awk
        # check if the first field in anyline is match with the entergroup 
        groupmatch=$(awk -F: -v group="$entergroup" '$1 == group {print}' /etc/group)
        
        # get the line number of the group by usig grep -n to get the line number, and cut to get the value of line number only
        numberline=$(grep -n $groupmatch /etc/group | cut -d: -f1 )
    

        #check if the group that user trying to add has the group member or not, if there are then we need to add the colon before the username 
        groupmember=$(grep -n $groupmatch /etc/group | cut -d: -f5 )
       
        
       
        
       
       
        if [[ -z $groupmember ]];then # if the group have no memeber
            sed -i "${numberline}s/$/$username/" /etc/group # insert the end of the line(line $linenumber) with username 
        else
            sed -i "${numberline}s/$/,$username/" /etc/group # insert the end of the line with username with , before the name
        fi

        
        echo "add user to group ${entergroup} sucessfully!" # me : need to change this to the if statement of checking that it work some how!!

    
     

    fi

}










while getopts "s:m:g:h" opt;do
    case $opt in 
    
        m)
        m_flag=true
        enterName=${OPTARG}
        ;;
        s)
        s_flag=true
        enterShell=${OPTARG}
        ;;
        g)
        g_flag=true
        enterGroup=${OPTARG}
        ;;
        h)
        h_flag=true
        ;;
        ?)
        echo "error"

        
        
        
    
    esac
done


### fix this if else statement- look so bad! (me: 2AM 10/31/2024)
if [[ ! -z $@ && ! $m_flag  && ! $h_flag ]];then
    echo "flag -m is required to use with other flag"
elif [[ ! -z $@ && $m_flag && ! $s_flag  && ! $g_flag ]];then
   
    create_user $enterName 
elif [[ ! -z $@ && $g_flag && ! $m_flag ]];then
    echo "to use -g, -m is required"
elif [[ ! -z $@ && $m_flag ]];then
    create_user $enterName $enterShell 
    if [[ ! $? -eq 1 ]];then
        adduserGroup $enterGroup $enterName
    fi
fi









#link
#https://www.baeldung.com/linux/find-available-shells#:~:text=To%20find%20available%20shells%20on,shells%20installed%20on%20the%20system.

#https://stackoverflow.com/questions/62887981/modifying-a-particular-line-in-a-text-file-from-the-command-line